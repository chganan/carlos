function array() {
    return Array.prototype.slice.call(arguments)
}

function array_key_exists(r, t) {
    return !(!t || t.constructor !== Array && t.constructor !== Object) && r in t
}

function array_keys(r, t, e) {
    var i = new Array,
        e = !!e,
        n = !0,
        s = 0;
    for (key in r) n = !0, void 0 != t && (e && r[key] !== t ? n = !1 : r[key] != t && (n = !1)), n && (i[s] = key, s++);
    return i
}

function in_array(r, t, e) {
    var i, n = !1,
        e = !!e;
    for (i in t)
        if (e && t[i] === r || !e && t[i] == r) {
            n = !0;
            break
        }
    return n
}

function sizeof(r, t) {
    return count(r, t)
}

function count(r, t) {
    var e, i = 0;
    "COUNT_RECURSIVE" == t && (t = 1), 1 != t && (t = 0);
    for (e in r) i++, 1 != t || !r[e] || r[e].constructor !== Array && r[e].constructor !== Object || (i += count(r[e], 1));
    return i
}

function explode(r, t, e) {
    var i = {
        0: ""
    };
    if (arguments.length < 2 || void 0 === arguments[0] || void 0 === arguments[1]) return null;
    if ("" === r || !1 === r || null === r) return !1;
    if ("function" == typeof r || "object" == typeof r || "function" == typeof t || "object" == typeof t) return i;
    if (!0 === r && (r = "1"), e) {
        var n = t.toString().split(r.toString()),
            s = n.splice(0, e - 1),
            a = n.join(r.toString());
        return s.push(a), s
    }
    return t.toString().split(r.toString())
}

function implode(r, t) {
    return t instanceof Array ? t.join(r) : t
}

function join(r, t) {
    return implode(r, t)
}

function split(r, t) {
    return explode(r, t)
}

function str_replace(r, t, e) {
    for (var i = r, n = e, s = is_array(o = t), a = is_array(n), i = [].concat(i), o = [].concat(o), u = (n = [].concat(n)).length; j = 0, u--;)
        for (; n[u] = n[u].split(i[j]).join(s ? o[j] || "" : o[0]), ++j in i;);
    return a ? n : n[0]
}

function strlen(r) {
    return ("" + r).length
}

function strpos(r, t, e) {
    var i = r.indexOf(t, e);
    return i >= 0 && i
}

function strrpos(r, t, e) {
    var i = r.lastIndexOf(t, e);
    return i >= 0 && i
}

function strtolower(r) {
    return r.toLowerCase()
}

function strtoupper(r) {
    return r.toUpperCase()
}

function substr(r, t, e) {
    return t < 0 && (t += r.length), void 0 == e ? e = r.length : e += e < 0 ? r.length : t, e < t && (e = t), r.substring(t, e)
}

function trim(r, t) {
    if (!r) return "";
    var e;
    e = t ? t.replace(/([\[\]\(\)\.\?\/\*\{\}\+\$\^\:])/g, "$1") : " \n\r\t\f\v            ​\u2028\u2029　";
    for (var i = 0; i < r.length; i++)
        if (-1 === e.indexOf(r.charAt(i))) {
            r = r.substring(i);
            break
        }
    for (i = r.length - 1; i >= 0; i--)
        if (-1 === e.indexOf(r.charAt(i))) {
            r = r.substring(0, i + 1);
            break
        }
    return -1 === e.indexOf(r.charAt(0)) ? r : ""
}

function wordwrap(r, t, e, i) {
    var n, s, a, o, u, h = t,
        l = e,
        c = i;
    if (h < 1) return r;
    for (n = -1, a = (u = r.split("\n")).length; ++n < a; u[n] += o)
        for (o = u[n], u[n] = ""; o.length > h; u[n] += o.slice(0, s) + ((o = o.slice(s)).length ? l : "")) s = 2 == c || (s = o.slice(0, h + 1).match(/\S*(\s)?$/))[1] ? h : s.input.length - s[0].length || 1 == c && h || s.input.length + (s = o.slice(h).match(/^\S*/)).input.length;
    return u.join("\n")
}

function is_string(r) {
    return "string" == typeof r
}

function ord(r) {
    return r.charCodeAt(0)
}

function array_unique(r) {
    var t, e, i, n = r;
    for (e = n.length; e;)
        for (t = --e; t > 0;)
            if (n[e] === n[--t]) {
                for (i = t; --t && n[e] === n[t];);
                e -= n.splice(t + 1, i - t).length
            }
    return n
}

function print_r(r, t) {
    var e = "",
        i = function(r, t, e, s) {
            t > 0 && t++;
            var a = n(e * t, s),
                o = n(e * (t + 1), s),
                u = "";
            if (r instanceof Array || r instanceof Object) {
                u += "Array\n" + a + "(\n";
                for (var h in r) r[h] instanceof Array || r[h] instanceof Object ? u += o + "[" + h + "] => " + i(r[h], t + 1, e, s) : u += o + "[" + h + "] => " + r[h] + "\n";
                u += a + ")\n"
            } else u = r.toString();
            return u
        },
        n = function(r, t) {
            for (var e = "", i = 0; i < r; i++) e += t;
            return e
        };
    return e = i(r, 0, 4, " "), !0 !== t ? (document.write("<pre>" + e + "</pre>"), !0) : e
}

function is_array(r) {
    return r instanceof Array
}

function BibTex(r) {
    void 0 === r && (r = {}), this.data, this.content, this._delimiters, this.warnings, this._options, this.rtfstring, this.htmlstring, this.allowedEntryTypes, this.authorstring, this._delimiters = {
        '"': '"',
        "{": "}"
    }, this.data = [], this.content = "", this.warnings = [], this._options = {
        stripDelimiter: !0,
        validate: !0,
        unwrap: !1,
        wordWrapWidth: !1,
        wordWrapBreak: "\n",
        wordWrapCut: 0,
        removeCurlyBraces: !1,
        extractAuthors: !0
    };
    for (option in r) test = this.setOption(option, r[option]), this.isError(test);
    this.rtfstring = 'AUTHORS, "{\b TITLE}", {i JOURNAL}, YEAR', this.htmlstring = 'AUTHORS, "<strong>TITLE</strong>", <em>JOURNAL</em>, YEAR<br />', this.allowedEntryTypes = array("article", "book", "booklet", "confernce", "inbook", "incollection", "inproceedings", "manual", "masterthesis", "misc", "phdthesis", "proceedings", "techreport", "unpublished"), this.authorstring = "VON LAST, JR, FIRST"
}
BibTex.prototype = {
    setOption: function(r, t) {
        return ret = !0, array_key_exists(r, this._options) ? this._options[r] = t : ret = this.raiseError("Unknown option " + r), ret
    },
    parse: function() {
        this.warnings = [], this.data = [];
        for (var r = !0, t = 0, e = !1, i = "", n = "", s = "", a = 0; a < strlen(this.content); a++) {
            if (i = substr(this.content, a, 1), 0 != t && "@" == i && (this._checkAt(s) || (this._generateWarning("WARNING_MISSING_END_BRACE", "", s), i = "}", a--)), 0 == t && "@" == i) e = !0;
            else if (e && "{" == i && "\\" != n) t++;
            else if (e && "}" == i && "\\" != n && (--t < 0 && (r = !1), 0 == t)) {
                e = !1;
                var o = this._parseEntry(s);
                o && (this.data[this.data.length] = o), s = ""
            }
            e && (s += i), n = i
        }
        if (1 == t && ((o = this._parseEntry(s)) ? (this.data[this.data.length] = o, s = "", t = 0) : r = !1), 0 != t && (r = !1), this._options.validate) {
            cites = [];
            for (a = 0; a < this.data.length; a++) cites[cites.length] = this.data[a].cite;
            if (unique = array_unique(cites), cites.length != sizeof(unique)) {
                notuniques = [];
                for (a = 0; a < cites.length; a++) "" == unique[a] && (notuniques[notuniques.length] = cites[a]);
                this._generateWarning("WARNING_MULTIPLE_ENTRIES", implode(",", notuniques))
            }
        }
        return r ? (this.content = "", !0) : this.raiseError("Unbalanced parenthesis")
    },
    _parseEntry: function(r) {
        var t = "";
        this._options.validate && (t = r);
        var e = {};
        if ("@string" == strtolower(substr(r, 0, 7))) this._options.validate && this._generateWarning("STRING_ENTRY_NOT_YET_SUPPORTED", "", r + "}");
        else if ("@preamble" == strtolower(substr(r, 0, 9))) this._options.validate && this._generateWarning("PREAMBLE_ENTRY_NOT_YET_SUPPORTED", "", r + "}");
        else {
            for (; !1 !== strrpos(r, "=");) {
                for (position = strrpos(r, "="), proceed = !0, "\\" == substr(r, position - 1, 1) && (proceed = !1), proceed && (proceed = this._checkEqualSign(r, position)); !proceed;) substring = substr(r, 0, position), position = strrpos(substring, "="), proceed = !0, "\\" == substr(r, position - 1, 1) && (proceed = !1), proceed && (proceed = this._checkEqualSign(r, position));
                value = trim(substr(r, position + 1)), r = substr(r, 0, position), "," == substr(value, strlen(value) - 1, 1) && (value = substr(value, 0, -1)), this._options.validate && this._validateValue(value, t), this._options.stripDelimiter && (value = this._stripDelimiter(value)), this._options.unwrap && (value = this._unwrap(value)), this._options.removeCurlyBraces && (value = this._removeCurlyBraces(value)), position = strrpos(r, ","), field = strtolower(trim(substr(r, position + 1))), e[field] = value, r = substr(r, 0, position)
            }
            var i = r.split("{");
            e.cite = trim(i[1]), e.entryType = strtolower(trim(i[0])), "@" == e.entryType.substring(0, 1) && (e.entryType = substr(e.entryType, 1)), this._options.validate && (this._checkAllowedEntryType(e.entryType) || this._generateWarning("WARNING_NOT_ALLOWED_ENTRY_TYPE", e.entryType, r + "}")), in_array("author", array_keys(e)) && this._options.extractAuthors && (e.author = this._extractAuthors(e.author))
        }
        return e
    },
    _checkEqualSign: function(r, t) {
        for (var e = !0, i = strlen(r), n = 0, s = i - 1; s >= t; s--) precedingchar = substr(r, s - 1, 1), charv = substr(r, s, 1), "{" == charv && "\\" != precedingchar && n++, "}" == charv && "\\" != precedingchar && n--;
        if (0 != n && (e = !1), e && (entrycopy = trim(r), lastchar = substr(entrycopy, strlen(entrycopy) - 1, 1), "," == lastchar && (lastchar = substr(entrycopy, strlen(entrycopy) - 2, 1)), '"' == lastchar)) {
            e = !1, found = 0;
            for (s = i; s >= t; s--)
                if (precedingchar = substr(r, s - 1, 1), charv = substr(r, s, 1), '"' == charv && "\\" != precedingchar && found++, 2 == found) {
                    e = !0;
                    break
                }
        }
        return e
    },
    _checkAllowedEntryType: function(r) {
        return in_array(r, this.allowedEntryTypes)
    },
    _checkAt: function(r) {
        var t = !1,
            e = array_keys(this._delimiters),
            i = array_values(this._delimiters);
        if (!1 !== strrpos(r, "=")) {
            for (position = strrpos(r, "="), proceed = !0, "\\" == substr(r, position - 1, 1) && (proceed = !1); !proceed;) substring = substr(r, 0, position), position = strrpos(substring, "="), proceed = !0, "\\" == substr(r, position - 1, 1) && (proceed = !1);
            value = trim(substr(r, position + 1)), open = 0, charv = "", lastchar = "";
            for (var n = 0; n < strlen(value); n++) charv = substr(this.content, n, 1), in_array(charv, e) && "\\" != lastchar ? open++ : in_array(charv, i) && "\\" != lastchar && open--, lastchar = charv;
            open > 0 && (t = !0)
        }
        return t
    },
    _stripDelimiter: function(r) {
        for (var t = array_keys(this._delimiters), e = (strlen(r), substr(r, 0, 1)), i = substr(r, -1, 1); in_array(e, t) && i == this._delimiters[e];) e = substr(r = substr(r, 1, -1), 0, 1), i = substr(r, -1, 1);
        return r
    },
    _unwrap: function(r) {
        return r = r.replace(/\s+/, " "), trim(r)
    },
    _wordwrap: function(r) {
        return "" != r && is_string(r) && (r = wordwrap(r, this._options.wordWrapWidth, this._options.wordWrapBreak, this._options.wordWrapCut)), r
    },
    _extractAuthors: function(r) {
        for (var t = (r = this._unwrap(r)).split(" and "), e = 0; e < t.length; e++) {
            var i = trim(t[e]),
                n = "",
                s = "",
                a = "",
                o = "";
            if (!1 === strpos(i, ",")) {
                var u = (_ = i.split(" |~")).length;
                if (1 == u) a = _[0];
                else if (2 == u) n = _[0], a = _[1];
                else {
                    for (var h = !1, l = !1, c = 0; c < u - 1; c++)
                        if (l) a += " " + _[c];
                        else if (h)
                        if (p = this._determineCase(_[c]), this.isError(p));
                        else if (0 == p || -1 == p) {
                        islast = !0;
                        for (f = c + 1; f < u - 1; f++) futurecase = this._determineCase(_[f]), this.isError(p) || 0 == futurecase && (islast = !1);
                        islast ? (l = !0, -1 == p ? a += " " + _[c] : s += " " + _[c]) : s += " " + _[c]
                    } else s += " " + _[c];
                    else {
                        var p = this._determineCase(_[c]);
                        this.isError(p) || (0 == p ? (h = !0, s += " " + _[c]) : n += " " + _[c])
                    }
                    a += " " + _[u - 1]
                }
            } else {
                var _ = [];
                if (_ = explode(",", i), vonlastarray = [], vonlastarray = explode(" ", _[0]), 1 == (u = sizeof(vonlastarray))) a = vonlastarray[0];
                else {
                    l = !1;
                    for (c = 0; c < u - 1; c++)
                        if (l) a += " " + vonlastarray[c];
                        else if (0 != this._determineCase(vonlastarray[c])) {
                        islast = !0;
                        for (var f = c + 1; f < u - 1; f++) this._determineCase(vonlastarray[f]), p = this._determineCase(vonlastarray[f]), this.isError(p) || 0 == p && (islast = !1);
                        islast ? (l = !0, a += " " + vonlastarray[c]) : s += " " + vonlastarray[c]
                    } else s += " " + vonlastarray[c];
                    a += " " + vonlastarray[u - 1]
                }
                3 == _.length && (o = _[1]), n = _[_.length - 1]
            }
            t[e] = {
                first: trim(n),
                von: trim(s),
                last: trim(a),
                jr: trim(o)
            }
        }
        return t
    },
    _determineCase: function(r) {
        var t = -1,
            e = trim(r);
        if (is_string(r) && strlen(e) > 0)
            for (var i = 0, n = !1, s = 0; !n && i <= strlen(r);) {
                var a = ord(substr(e, i, 1));
                123 == a && s++, 125 == a && s--, a >= 65 && a <= 90 && 0 == s ? (t = 1, n = !0) : a >= 97 && a <= 122 && 0 == s ? (t = 0, n = !0) : i++
            } else t = this.raiseError("Could not determine case on word: " + r);
        return t
    },
    isError: function(r) {
        return "Object" == typeof r && 1 == r.isError
    },
    _validateValue: function(r, t) {
        r.match(/^{.*@.*}/) && this._generateWarning("WARNING_AT_IN_BRACES", r, t), r.match(/^\".*\\".*\"/) && this._generateWarning("WARNING_ESCAPED_DOUBLE_QUOTE_INSIDE_DOUBLE_QUOTES", r, t);
        for (var e = 0, i = "", n = "", s = 0; s < strlen(r); s++) "{" == (n = substr(r, s, 1)) && "\\" != i && e++, "}" == n && "\\" != i && e--, i = n;
        0 != e && this._generateWarning("WARNING_UNBALANCED_AMOUNT_OF_BRACES", r, t)
    },
    _removeCurlyBraces: function(r) {
        for (var t = array_keys(this._delimiters), e = substr(r, 0, 1), i = substr(r, -1, 1), n = "", s = ""; in_array(e, t) && i == this._delimiters[e];) n += e, s += i, e = substr(r = substr(r, 1, -1), 0, 1), i = substr(r, -1, 1);
        return r = r.replace(/([^\\\\])\{(.*?[^\\\\])\}/, "12"), r = n + r + s
    },
    _generateWarning: function(r, t, e) {
        void 0 === e && (e = "");
        var i = {};
        i.warning = r, i.entry = t, i.wholeentry = e, this.warnings[this.warnings.length] = i
    },
    clearWarnings: function() {
        this.warnings = array()
    },
    hasWarning: function() {
        return sizeof(this.warnings) > 0
    },
    amount: function() {
        return sizeof(this.data)
    },
    _formatAuthor: function(r) {
        return array_key_exists("von", r) ? r.von = trim(r.von) : r.von = "", array_key_exists("last", r) ? r.last = trim(r.last) : r.last = "", array_key_exists("jr", r) ? r.jr = trim(r.jr) : r.jr = "", array_key_exists("first", r) ? r.first = trim(r.first) : r.first = "", ret = this.authorstring, ret = str_replace("VON", r.von, ret), ret = str_replace("LAST", r.last, ret), ret = str_replace("JR", r.jr, ret), ret = str_replace("FIRST", r.first, ret), trim(ret)
    },
    bibTex: function() {
        for (var r = "", t = 0; t < this.data.length; t++) {
            var e = this.data[t];
            r += "@" + strtolower(e.entryType) + " { " + e.cite + ",\n";
            for (key in e) {
                var i = e[key];
                this._options.wordWrapWidth > 0 && (i = this._wordWrap(i)), in_array(key, array("cite", "entryType", "author")) || (r += "\t" + key + " = {" + i + "},\n")
            }
            if (array_key_exists("author", e))
                if (this._options.extractAuthors) {
                    tmparray = [];
                    for (j in e.author) {
                        var n = e.author[j];
                        tmparray[tmparray.length] = this._formatAuthor(n)
                    }
                    author = join(" and ", tmparray)
                } else author = e.author;
            else author = "";
            r += "\tauthor = {" + author + "}\n", r += "}\n\n"
        }
        return r
    },
    addEntry: function(r) {
        this.data[this.data.length] = r
    },
    getStatistic: function() {
        for (var r = array(), t = 0; t < this.data.length; t++) {
            var e = this.data[t];
            array_key_exists(e.entryType, r) ? r[e.entryType]++ : r[e.entryType] = 1
        }
        return r
    },
    rtf: function() {
        for (var r = "{\\rtf\n", t = 0; t < this.data.length; t++) {
            var e = this.data[t];
            if (line = this.rtfstring, title = "", journal = "", year = "", authors = "", array_key_exists("title", e) && (title = this._unwrap(e.title)), array_key_exists("journal", e) && (journal = this._unwrap(e.journal)), array_key_exists("year", e) && (year = this._unwrap(e.year)), array_key_exists("author", e))
                if (this._options.extractAuthors) {
                    tmparray = [];
                    for (var i in e.author) {
                        var n = e.author[i];
                        tmparray[tmparray.length] = this._formatAuthor(n)
                    }
                    authors = join(", ", tmparray)
                } else authors = e.author;
            "" != title || "" != journal || "" != year || "" != authors ? (line = str_replace("TITLE", title, line), line = str_replace("JOURNAL", journal, line), line = str_replace("YEAR", year, line), line = str_replace("AUTHORS", authors, line), line += "\n\\par\n", r += line) : this._generateWarning("WARNING_LINE_WAS_NOT_CONVERTED", "", print_r(e, 1))
        }
        return r += "}"
    },
    html: function(r, t) {
        void 0 === r && (r = 0), void 0 === t && (t = this.data.length);
        for (var e = "<p>\n", i = r; i < t; i++) {
            var n = this.data[i],
                s = this.htmlstring,
                a = "",
                o = "",
                u = "",
                h = "";
            if (array_key_exists("title", n) && (a = this._unwrap(n.title)), array_key_exists("journal", n) && (o = this._unwrap(n.journal)), array_key_exists("year", n) && (u = this._unwrap(n.year)), array_key_exists("author", n))
                if (this._options.extractAuthors) {
                    tmparray = [];
                    for (j in n.author) {
                        var l = n.author[j];
                        tmparray[tmparray.length] = this._formatAuthor(l)
                    }
                    h = join(", ", tmparray)
                } else h = n.author;
            "" != a || "" != o || "" != u || "" != h ? (s = str_replace("AUTHORS", h, s = str_replace("YEAR", u, s = str_replace("JOURNAL", o, s = str_replace("TITLE", a, s)))), e += s += "\n") : this._generateWarning("WARNING_LINE_WAS_NOT_CONVERTED", "", print_r(n, 1))
        }
        return e += "</p>\n"
    }
};